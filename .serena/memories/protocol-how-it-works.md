# How Protocol Engineering Works

## Quick Start
1. New session: Claude reads CLAUDE.md → follows protocol-engineering.md
2. Startup Protocol: reads memories → continues work
3. All tasks follow protocols → consistent quality
4. Learning happens through memories → improves over time

## Test Coverage Integration
- TDD mandatory: Write test → See fail → Code → See pass
- 100% coverage required (exceptions need permission)
- Tests run until ALL pass
- Clear naming: Test{Function}_{Scenario}_{Result}

## Learning Mechanism
1. **Pattern Recognition**: Save solutions as patterns
2. **Decision History**: Document why choices were made  
3. **Cross-Project**: Knowledge transfers between projects
4. **Reflection**: "What would I do differently?"

## Why This Works
- No re-explaining context (memories persist)
- Consistent approach (protocols guide actions)
- Continuous improvement (learning from each task)
- Team member, not tool (proactive, remembers, evolves)

## Testing the System
1. Activate project with protocol
2. Give complex task spanning 2 sessions
3. Check if Claude continues seamlessly
4. Verify 100% test coverage achieved
5. See if patterns get reused