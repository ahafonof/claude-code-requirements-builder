
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>claude-code-requirements-builder: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/ahafonof/claude-code-requirements-builder/activity_feed.go (100.0%)</option>
				
				<option value="file1">github.com/ahafonof/claude-code-requirements-builder/distributed_ratelimiter.go (87.0%)</option>
				
				<option value="file2">github.com/ahafonof/claude-code-requirements-builder/main.go (72.9%)</option>
				
				<option value="file3">github.com/ahafonof/claude-code-requirements-builder/ratelimiter.go (97.4%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "fmt"
        "net/http"
        "sync"
        "time"
)

// Event types for activity feed
const (
        EventTypeRateLimitRejected        = "rate_limit_rejected"
        EventTypeCircuitBreakerStateChange = "circuit_breaker_state_change"
        EventTypeRedisFailure             = "redis_failure"
)

// ActivityEvent represents a system event for the activity feed
type ActivityEvent struct {
        ID        string                 `json:"id"`
        Type      string                 `json:"type"`
        Timestamp time.Time              `json:"timestamp"`
        IP        string                 `json:"ip,omitempty"`
        Path      string                 `json:"path,omitempty"`
        Details   map[string]interface{} `json:"details,omitempty"`
}

// ActivityFeed manages a circular buffer of events
type ActivityFeed struct {
        events   []*ActivityEvent
        size     int
        position int
        mu       sync.RWMutex
}

// NewActivityFeed creates a new activity feed with specified buffer size
func NewActivityFeed(size int) *ActivityFeed <span class="cov8" title="1">{
        return &amp;ActivityFeed{
                events: make([]*ActivityEvent, size),
                size:   size,
        }
}</span>

// AddEvent adds an event to the circular buffer
func (af *ActivityFeed) AddEvent(event *ActivityEvent) <span class="cov8" title="1">{
        af.mu.Lock()
        defer af.mu.Unlock()

        af.events[af.position] = event
        af.position = (af.position + 1) % af.size
}</span>

// GetRecentEvents returns the most recent events up to the specified limit
func (af *ActivityFeed) GetRecentEvents(limit int) []*ActivityEvent <span class="cov8" title="1">{
        af.mu.RLock()
        defer af.mu.RUnlock()

        result := make([]*ActivityEvent, 0, limit)
        
        // Calculate how many events we have
        count := 0
        for _, event := range af.events </span><span class="cov8" title="1">{
                if event != nil </span><span class="cov8" title="1">{
                        count++
                }</span>
        }

        // If we have fewer events than the buffer size, return all
        <span class="cov8" title="1">if count &lt; af.size </span><span class="cov8" title="1">{
                for i := 0; i &lt; count &amp;&amp; len(result) &lt; limit; i++ </span><span class="cov8" title="1">{
                        if af.events[i] != nil </span><span class="cov8" title="1">{
                                result = append(result, af.events[i])
                        }</span>
                }
                <span class="cov8" title="1">return result</span>
        }

        // Otherwise, return events in order from oldest to newest
        // Start from position (oldest) and go around
        <span class="cov8" title="1">for i := 0; i &lt; af.size &amp;&amp; len(result) &lt; limit; i++ </span><span class="cov8" title="1">{
                idx := (af.position + i) % af.size
                if af.events[idx] != nil </span><span class="cov8" title="1">{
                        result = append(result, af.events[idx])
                }</span>
        }

        <span class="cov8" title="1">return result</span>
}

// SSEClient represents a Server-Sent Events client
type SSEClient struct {
        Events         chan *ActivityEvent
        Done           chan bool
        ResponseWriter http.ResponseWriter
}

// SSEBroadcaster manages SSE client connections and broadcasts events
type SSEBroadcaster struct {
        clients map[*SSEClient]bool
        mu      sync.RWMutex
}

// NewSSEBroadcaster creates a new SSE broadcaster
func NewSSEBroadcaster() *SSEBroadcaster <span class="cov8" title="1">{
        return &amp;SSEBroadcaster{
                clients: make(map[*SSEClient]bool),
        }
}</span>

// Subscribe adds a new client to the broadcaster
func (b *SSEBroadcaster) Subscribe(w http.ResponseWriter) *SSEClient <span class="cov8" title="1">{
        client := &amp;SSEClient{
                Events:         make(chan *ActivityEvent, 10), // Buffered channel
                Done:           make(chan bool),
                ResponseWriter: w,
        }

        b.mu.Lock()
        b.clients[client] = true
        b.mu.Unlock()

        return client
}</span>

// Unsubscribe removes a client from the broadcaster
func (b *SSEBroadcaster) Unsubscribe(client *SSEClient) <span class="cov8" title="1">{
        b.mu.Lock()
        delete(b.clients, client)
        b.mu.Unlock()
        
        close(client.Events)
        close(client.Done)
}</span>

// GetClientCount returns the number of connected clients
func (b *SSEBroadcaster) GetClientCount() int <span class="cov8" title="1">{
        b.mu.RLock()
        defer b.mu.RUnlock()
        return len(b.clients)
}</span>

// Broadcast sends an event to all connected clients (non-blocking)
func (b *SSEBroadcaster) Broadcast(event *ActivityEvent) <span class="cov8" title="1">{
        b.mu.RLock()
        clients := make([]*SSEClient, 0, len(b.clients))
        for client := range b.clients </span><span class="cov8" title="1">{
                clients = append(clients, client)
        }</span>
        <span class="cov8" title="1">b.mu.RUnlock()

        // Send to clients without blocking
        for _, client := range clients </span><span class="cov8" title="1">{
                select </span>{
                case client.Events &lt;- event:<span class="cov8" title="1"></span>
                        // Event sent successfully
                default:<span class="cov8" title="1"></span>
                        // Client buffer full, drop event (non-blocking behavior)
                }
        }
}

// EventEmitter integrates ActivityFeed and SSEBroadcaster
type EventEmitter struct {
        feed        *ActivityFeed
        broadcaster *SSEBroadcaster
}

// Emit adds an event to the feed and broadcasts it
func (e *EventEmitter) Emit(event *ActivityEvent) <span class="cov8" title="1">{
        e.feed.AddEvent(event)
        e.broadcaster.Broadcast(event)
}</span>

// EmitRateLimitRejection emits a rate limit rejection event
func (e *EventEmitter) EmitRateLimitRejection(r *http.Request) <span class="cov8" title="1">{
        event := &amp;ActivityEvent{
                ID:        fmt.Sprintf("rl-%d", time.Now().UnixNano()),
                Type:      EventTypeRateLimitRejected,
                Timestamp: time.Now(),
                IP:        getClientIP(r),
                Path:      r.URL.Path,
                Details: map[string]interface{}{
                        "method": r.Method,
                },
        }
        e.Emit(event)
}</span>

// EmitCircuitBreakerStateChange emits a circuit breaker state change event
func (e *EventEmitter) EmitCircuitBreakerStateChange(oldState, newState string, failures int) <span class="cov8" title="1">{
        event := &amp;ActivityEvent{
                ID:        fmt.Sprintf("cb-%d", time.Now().UnixNano()),
                Type:      EventTypeCircuitBreakerStateChange,
                Timestamp: time.Now(),
                Details: map[string]interface{}{
                        "old_state": oldState,
                        "new_state": newState,
                        "failures":  failures,
                },
        }
        e.Emit(event)
}</span>

// EmitRedisFailure emits a Redis failure event
func (e *EventEmitter) EmitRedisFailure(operation string, err error) <span class="cov8" title="1">{
        event := &amp;ActivityEvent{
                ID:        fmt.Sprintf("rf-%d", time.Now().UnixNano()),
                Type:      EventTypeRedisFailure,
                Timestamp: time.Now(),
                Details: map[string]interface{}{
                        "operation": operation,
                        "error":     err.Error(),
                },
        }
        e.Emit(event)
}</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "context"
        "net/http"
        "sync"
        "time"
        
        "github.com/redis/go-redis/v9"
        "github.com/google/uuid"
)

// CircuitState represents the state of the circuit breaker
type CircuitState int

const (
        StateClosed    CircuitState = iota // Normal operation (using Redis)
        StateOpen                           // Circuit open (using fallback)
        StateHalfOpen                       // Testing if Redis is available again
)

// Config for distributed rate limiter
type Config struct {
        RedisURL         string
        Limit            int
        Window           time.Duration
        FailureThreshold int
        RecoveryInterval time.Duration
}

// Metrics tracks rate limiter performance
type Metrics struct {
        mu               sync.RWMutex
        TotalRequests    int64
        AllowedRequests  int64
        RejectedRequests int64
        RedisLatency     time.Duration
        RedisFailures    int64
        FallbackMode     string
        FallbackCount    int64
        LastUpdated      time.Time
}

// CircuitBreaker manages Redis connection health
type CircuitBreaker struct {
        mu               sync.RWMutex
        state            CircuitState
        failures         int
        failureThreshold int
        lastFailureTime  time.Time
        recoveryInterval time.Duration
}

// DistributedRateLimiter extends basic rate limiter with Redis support
type DistributedRateLimiter struct {
        redisClient     *redis.Client
        fallbackLimiter *RateLimiter
        circuitBreaker  *CircuitBreaker
        metrics         *Metrics
        config          *Config
        luaScript       *redis.Script
        ctx             context.Context
        eventEmitter    *EventEmitter
}

// NewDistributedRateLimiter creates a new distributed rate limiter
func NewDistributedRateLimiter(cfg *Config, eventEmitter *EventEmitter) (*DistributedRateLimiter, error) <span class="cov8" title="1">{
        // Initialize Redis client
        opt, err := redis.ParseURL(cfg.RedisURL)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        
        <span class="cov8" title="1">redisClient := redis.NewClient(opt)
        ctx := context.Background()
        
        // Test Redis connection
        if err := redisClient.Ping(ctx).Err(); err != nil </span><span class="cov8" title="1">{
                // Redis not available, but we'll continue with fallback
                // Log the error for debugging purposes
                _ = err
        }</span>
        
        // Create fallback limiter
        <span class="cov8" title="1">fallbackLimiter := &amp;RateLimiter{
                requests: make(map[string][]time.Time),
                limit:    cfg.Limit,
                window:   cfg.Window,
        }
        
        // Create circuit breaker
        circuitBreaker := &amp;CircuitBreaker{
                state:            StateClosed,
                failureThreshold: cfg.FailureThreshold,
                recoveryInterval: cfg.RecoveryInterval,
        }
        
        // Initialize metrics
        metrics := &amp;Metrics{
                FallbackMode: "distributed",
                LastUpdated:  time.Now(),
        }
        
        // Lua script for atomic rate limiting
        luaScript := redis.NewScript(`
                local key = KEYS[1]
                local now = ARGV[1]
                local windowStart = ARGV[2]
                local limit = tonumber(ARGV[3])
                local requestId = ARGV[4]
                
                -- Remove old entries
                redis.call('ZREMRANGEBYSCORE', key, 0, windowStart)
                
                -- Count current requests
                local count = redis.call('ZCARD', key)
                
                -- Check limit
                if count &gt;= limit then
                        return 0
                else
                        redis.call('ZADD', key, now, requestId)
                        redis.call('EXPIRE', key, 120)
                        return 1
                end
        `)
        
        drl := &amp;DistributedRateLimiter{
                redisClient:     redisClient,
                fallbackLimiter: fallbackLimiter,
                circuitBreaker:  circuitBreaker,
                metrics:         metrics,
                config:          cfg,
                luaScript:       luaScript,
                ctx:             ctx,
                eventEmitter:    eventEmitter,
        }
        
        // Start recovery goroutine
        go drl.startRecoveryMonitor()
        
        return drl, nil</span>
}

// Allow checks if request from IP should be allowed
func (drl *DistributedRateLimiter) Allow(ip string) bool <span class="cov8" title="1">{
        start := time.Now()
        drl.metrics.mu.Lock()
        drl.metrics.TotalRequests++
        drl.metrics.mu.Unlock()
        
        // Check circuit breaker state
        if drl.circuitBreaker.IsOpen() </span><span class="cov8" title="1">{
                return drl.fallbackAllow(ip)
        }</span>
        
        // Try Redis operation
        <span class="cov8" title="1">allowed, err := drl.redisAllow(ip)
        if err != nil </span><span class="cov8" title="1">{
                drl.circuitBreaker.RecordFailure(drl.eventEmitter)
                // Emit Redis failure event
                if drl.eventEmitter != nil </span><span class="cov8" title="1">{
                        drl.eventEmitter.EmitRedisFailure("rate_limit_check", err)
                }</span>
                <span class="cov8" title="1">return drl.fallbackAllow(ip)</span>
        }
        
        // Record success
        <span class="cov0" title="0">drl.circuitBreaker.RecordSuccess()
        drl.recordMetrics(allowed, time.Since(start), false)
        
        return allowed</span>
}

// AllowWithRequest checks if request should be allowed and emits events
func (drl *DistributedRateLimiter) AllowWithRequest(ip string, r *http.Request) bool <span class="cov8" title="1">{
        allowed := drl.Allow(ip)
        
        // Emit rate limit rejection event if applicable
        if !allowed &amp;&amp; drl.eventEmitter != nil </span><span class="cov8" title="1">{
                drl.eventEmitter.EmitRateLimitRejection(r)
        }</span>
        
        <span class="cov8" title="1">return allowed</span>
}

// redisAllow performs rate limiting using Redis
func (drl *DistributedRateLimiter) redisAllow(ip string) (bool, error) <span class="cov8" title="1">{
        key := "rate_limit:" + ip
        now := time.Now().UnixMilli()
        windowStart := now - int64(drl.config.Window.Milliseconds())
        requestID := uuid.New().String()
        
        result, err := drl.luaScript.Run(
                drl.ctx,
                drl.redisClient,
                []string{key},
                now,
                windowStart,
                drl.config.Limit,
                requestID,
        ).Result()
        
        if err != nil </span><span class="cov8" title="1">{
                return false, err
        }</span>
        
        <span class="cov0" title="0">allowed := result.(int64) == 1
        return allowed, nil</span>
}

// fallbackAllow uses local rate limiter when Redis is unavailable
func (drl *DistributedRateLimiter) fallbackAllow(ip string) bool <span class="cov8" title="1">{
        drl.metrics.mu.Lock()
        drl.metrics.FallbackCount++
        drl.metrics.FallbackMode = "fallback"
        drl.metrics.mu.Unlock()
        
        allowed := drl.fallbackLimiter.allow(ip)
        drl.recordMetrics(allowed, 0, true)
        
        return allowed
}</span>

// recordMetrics updates performance metrics
func (drl *DistributedRateLimiter) recordMetrics(allowed bool, latency time.Duration, isFallback bool) <span class="cov8" title="1">{
        drl.metrics.mu.Lock()
        defer drl.metrics.mu.Unlock()
        
        if allowed </span><span class="cov8" title="1">{
                drl.metrics.AllowedRequests++
        }</span> else<span class="cov8" title="1"> {
                drl.metrics.RejectedRequests++
        }</span>
        
        <span class="cov8" title="1">if !isFallback </span><span class="cov0" title="0">{
                drl.metrics.RedisLatency = latency
        }</span>
        
        <span class="cov8" title="1">drl.metrics.LastUpdated = time.Now()</span>
}

// GetMetrics returns current metrics
func (drl *DistributedRateLimiter) GetMetrics() Metrics <span class="cov8" title="1">{
        drl.metrics.mu.RLock()
        defer drl.metrics.mu.RUnlock()
        
        // Create a copy without the mutex
        return Metrics{
                TotalRequests:    drl.metrics.TotalRequests,
                AllowedRequests:  drl.metrics.AllowedRequests,
                RejectedRequests: drl.metrics.RejectedRequests,
                RedisLatency:     drl.metrics.RedisLatency,
                RedisFailures:    drl.metrics.RedisFailures,
                FallbackMode:     drl.metrics.FallbackMode,
                FallbackCount:    drl.metrics.FallbackCount,
                LastUpdated:      drl.metrics.LastUpdated,
        }
}</span>

// startRecoveryMonitor periodically checks if Redis is available
func (drl *DistributedRateLimiter) startRecoveryMonitor() <span class="cov8" title="1">{
        ticker := time.NewTicker(drl.config.RecoveryInterval)
        defer ticker.Stop()
        
        for range ticker.C </span><span class="cov8" title="1">{
                if drl.circuitBreaker.IsOpen() </span><span class="cov8" title="1">{
                        // Try to ping Redis
                        if err := drl.redisClient.Ping(drl.ctx).Err(); err == nil </span><span class="cov0" title="0">{
                                drl.circuitBreaker.Reset()
                                drl.metrics.mu.Lock()
                                drl.metrics.FallbackMode = "distributed"
                                drl.metrics.mu.Unlock()
                        }</span>
                }
        }
}

// Close closes Redis connection
func (drl *DistributedRateLimiter) Close() error <span class="cov8" title="1">{
        return drl.redisClient.Close()
}</span>

// CircuitBreaker methods

// IsOpen checks if circuit is open
func (cb *CircuitBreaker) IsOpen() bool <span class="cov8" title="1">{
        cb.mu.RLock()
        defer cb.mu.RUnlock()
        
        return cb.state == StateOpen
}</span>

// RecordFailure records a Redis failure
func (cb *CircuitBreaker) RecordFailure(eventEmitter *EventEmitter) <span class="cov8" title="1">{
        cb.mu.Lock()
        defer cb.mu.Unlock()
        
        oldState := cb.state
        cb.failures++
        cb.lastFailureTime = time.Now()
        
        if cb.failures &gt;= cb.failureThreshold </span><span class="cov8" title="1">{
                cb.state = StateOpen
                // Emit circuit breaker state change event
                if eventEmitter != nil &amp;&amp; oldState != StateOpen </span><span class="cov0" title="0">{
                        stateNames := map[CircuitState]string{
                                StateClosed:   "closed",
                                StateOpen:     "open",
                                StateHalfOpen: "half-open",
                        }
                        eventEmitter.EmitCircuitBreakerStateChange(stateNames[oldState], stateNames[StateOpen], cb.failures)
                }</span>
        }
}

// RecordSuccess records a successful Redis operation
func (cb *CircuitBreaker) RecordSuccess() <span class="cov8" title="1">{
        cb.mu.Lock()
        defer cb.mu.Unlock()
        
        if cb.state == StateHalfOpen </span><span class="cov8" title="1">{
                cb.state = StateClosed
                cb.failures = 0
        }</span>
}

// Reset attempts to reset the circuit breaker
func (cb *CircuitBreaker) Reset() <span class="cov8" title="1">{
        cb.mu.Lock()
        defer cb.mu.Unlock()
        
        if cb.state == StateOpen </span><span class="cov8" title="1">{
                cb.state = StateHalfOpen
        }</span>
}</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "encoding/json"
        "fmt"
        "log"
        "net/http"
        "time"
)

type Response struct {
        Message string `json:"message"`
        Status  int    `json:"status"`
}

func healthHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        resp := Response{
                Message: "API is healthy",
                Status:  http.StatusOK,
        }
        w.Header().Set("Content-Type", "application/json")
        _ = json.NewEncoder(w).Encode(resp)
}</span>

func usersHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        resp := Response{
                Message: "Users endpoint",
                Status:  http.StatusOK,
        }
        w.Header().Set("Content-Type", "application/json")
        _ = json.NewEncoder(w).Encode(resp)
}</span>

func productsHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        resp := Response{
                Message: "Products endpoint",
                Status:  http.StatusOK,
        }
        w.Header().Set("Content-Type", "application/json")
        _ = json.NewEncoder(w).Encode(resp)
}</span>

// metricsHandler returns rate limiter metrics
func metricsHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodGet </span><span class="cov8" title="1">{
                w.WriteHeader(http.StatusMethodNotAllowed)
                return
        }</span>
        
        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        
        // Create metrics response
        metricsData := struct {
                Mode             string    `json:"mode"`
                TotalRequests    int64     `json:"total_requests"`
                AllowedRequests  int64     `json:"allowed_requests"`
                RejectedRequests int64     `json:"rejected_requests"`
                RedisLatency     string    `json:"redis_latency,omitempty"`
                RedisFailures    int64     `json:"redis_failures,omitempty"`
                FallbackCount    int64     `json:"fallback_count,omitempty"`
                LastUpdated      string    `json:"last_updated"`
                CircuitState     string    `json:"circuit_state,omitempty"`
        }{
                Mode: "in-memory",
                LastUpdated: time.Now().Format(time.RFC3339),
        }
        
        // If using distributed limiter, get its metrics
        if useDistributed &amp;&amp; distributedLimiter != nil </span><span class="cov8" title="1">{
                metrics := distributedLimiter.GetMetrics()
                metricsData.Mode = metrics.FallbackMode
                metricsData.TotalRequests = metrics.TotalRequests
                metricsData.AllowedRequests = metrics.AllowedRequests
                metricsData.RejectedRequests = metrics.RejectedRequests
                metricsData.RedisLatency = metrics.RedisLatency.String()
                metricsData.RedisFailures = metrics.RedisFailures
                metricsData.FallbackCount = metrics.FallbackCount
                metricsData.LastUpdated = metrics.LastUpdated.Format(time.RFC3339)
                
                // Add circuit breaker state
                if distributedLimiter.circuitBreaker.IsOpen() </span><span class="cov0" title="0">{
                        metricsData.CircuitState = "open"
                }</span> else<span class="cov8" title="1"> {
                        metricsData.CircuitState = "closed"
                }</span>
        }
        
        <span class="cov8" title="1">_ = json.NewEncoder(w).Encode(metricsData)</span>
}

// GetEventEmitter returns the global event emitter
func GetEventEmitter() *EventEmitter <span class="cov8" title="1">{
        return globalEventEmitter
}</span>

// sseHandler handles Server-Sent Events connections
func sseHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        // Set SSE headers
        w.Header().Set("Content-Type", "text/event-stream")
        w.Header().Set("Cache-Control", "no-cache")
        w.Header().Set("Connection", "keep-alive")
        w.Header().Set("Access-Control-Allow-Origin", "*")

        // Get event emitter
        emitter := GetEventEmitter()
        if emitter == nil </span><span class="cov8" title="1">{
                http.Error(w, "Event system not initialized", http.StatusInternalServerError)
                return
        }</span>

        // Subscribe client
        <span class="cov8" title="1">client := emitter.broadcaster.Subscribe(w)
        defer emitter.broadcaster.Unsubscribe(client)

        // Send initial events from feed
        recentEvents := emitter.feed.GetRecentEvents(50)
        for _, event := range recentEvents </span><span class="cov8" title="1">{
                data, err := json.Marshal(event)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">_, _ = fmt.Fprintf(w, "data: %s\n\n", data)</span>
        }

        // Flush to send initial events
        <span class="cov8" title="1">if f, ok := w.(http.Flusher); ok </span><span class="cov8" title="1">{
                f.Flush()
        }</span>

        // Keep connection open and send events
        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                select </span>{
                case event := &lt;-client.Events:<span class="cov0" title="0">
                        data, err := json.Marshal(event)
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">_, _ = fmt.Fprintf(w, "data: %s\n\n", data)
                        if f, ok := w.(http.Flusher); ok </span><span class="cov0" title="0">{
                                f.Flush()
                        }</span>
                case &lt;-client.Done:<span class="cov0" title="0">
                        return</span>
                case &lt;-r.Context().Done():<span class="cov8" title="1">
                        return</span>
                }
        }
}

// activityFeedHandler serves the HTML interface for activity feed
func activityFeedHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        html := `&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Rate Limiter Activity Feed&lt;/title&gt;
    &lt;style&gt;
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        h1 {
            color: #333;
        }
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        .stat-card {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .stat-label {
            font-size: 14px;
            color: #666;
            margin-bottom: 5px;
        }
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #333;
        }
        .events {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            max-height: 600px;
            overflow-y: auto;
        }
        .event {
            padding: 10px;
            border-left: 3px solid #ddd;
            margin-bottom: 10px;
            background: #fafafa;
        }
        .event.rate_limit_rejected {
            border-left-color: #e74c3c;
            background: #fff5f5;
        }
        .event.circuit_breaker_state_change {
            border-left-color: #f39c12;
            background: #fffaf0;
        }
        .event.redis_failure {
            border-left-color: #e67e22;
            background: #fff8f0;
        }
        .event-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }
        .event-type {
            font-weight: bold;
            font-size: 14px;
        }
        .event-time {
            font-size: 12px;
            color: #666;
        }
        .event-details {
            font-size: 13px;
            color: #444;
        }
        .status {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
            margin-left: 10px;
        }
        .status.connected {
            background: #27ae60;
            color: white;
        }
        .status.disconnected {
            background: #e74c3c;
            color: white;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class="container"&gt;
        &lt;h1&gt;
            Rate Limiter Activity Feed
            &lt;span id="connection-status" class="status disconnected"&gt;Disconnected&lt;/span&gt;
        &lt;/h1&gt;
        
        &lt;div class="stats"&gt;
            &lt;div class="stat-card"&gt;
                &lt;div class="stat-label"&gt;Total Events&lt;/div&gt;
                &lt;div class="stat-value" id="total-events"&gt;0&lt;/div&gt;
            &lt;/div&gt;
            &lt;div class="stat-card"&gt;
                &lt;div class="stat-label"&gt;Rate Limit Rejections&lt;/div&gt;
                &lt;div class="stat-value" id="rate-limit-rejections"&gt;0&lt;/div&gt;
            &lt;/div&gt;
            &lt;div class="stat-card"&gt;
                &lt;div class="stat-label"&gt;Circuit Breaker Changes&lt;/div&gt;
                &lt;div class="stat-value" id="circuit-breaker-changes"&gt;0&lt;/div&gt;
            &lt;/div&gt;
            &lt;div class="stat-card"&gt;
                &lt;div class="stat-label"&gt;Redis Failures&lt;/div&gt;
                &lt;div class="stat-value" id="redis-failures"&gt;0&lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        
        &lt;h2&gt;Recent Events&lt;/h2&gt;
        &lt;div class="events" id="events-container"&gt;
            &lt;p&gt;Waiting for events...&lt;/p&gt;
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;script&gt;
        const eventsContainer = document.getElementById('events-container');
        const connectionStatus = document.getElementById('connection-status');
        const stats = {
            total: 0,
            rate_limit_rejected: 0,
            circuit_breaker_state_change: 0,
            redis_failure: 0
        };

        function updateStats() {
            document.getElementById('total-events').textContent = stats.total;
            document.getElementById('rate-limit-rejections').textContent = stats.rate_limit_rejected;
            document.getElementById('circuit-breaker-changes').textContent = stats.circuit_breaker_state_change;
            document.getElementById('redis-failures').textContent = stats.redis_failure;
        }

        function addEvent(event) {
            stats.total++;
            if (stats[event.type] !== undefined) {
                stats[event.type]++;
            }
            updateStats();

            const eventEl = document.createElement('div');
            eventEl.className = 'event ' + event.type;
            
            const time = new Date(event.timestamp).toLocaleTimeString();
            let detailsHtml = '';
            
            if (event.type === 'rate_limit_rejected') {
                detailsHtml = 'IP: ' + event.ip + ', Path: ' + event.path;
            } else if (event.type === 'circuit_breaker_state_change') {
                detailsHtml = 'State: ' + event.details.old_state + ' â†’ ' + event.details.new_state;
                if (event.details.failures) {
                    detailsHtml += ', Failures: ' + event.details.failures;
                }
            } else if (event.type === 'redis_failure') {
                detailsHtml = 'Operation: ' + event.details.operation + ', Error: ' + event.details.error;
            }
            
            eventEl.innerHTML = ` + "`" + `
                &lt;div class="event-header"&gt;
                    &lt;span class="event-type"&gt;${event.type.replace(/_/g, ' ').toUpperCase()}&lt;/span&gt;
                    &lt;span class="event-time"&gt;${time}&lt;/span&gt;
                &lt;/div&gt;
                &lt;div class="event-details"&gt;${detailsHtml}&lt;/div&gt;
            ` + "`" + `;
            
            // Remove "waiting" message if present
            const waitingMsg = eventsContainer.querySelector('p');
            if (waitingMsg) {
                waitingMsg.remove();
            }
            
            eventsContainer.insertBefore(eventEl, eventsContainer.firstChild);
            
            // Keep only last 100 events in DOM
            while (eventsContainer.children.length &gt; 100) {
                eventsContainer.removeChild(eventsContainer.lastChild);
            }
        }

        function connect() {
            const evtSource = new EventSource('/api/events/stream');
            
            evtSource.onopen = function() {
                connectionStatus.textContent = 'Connected';
                connectionStatus.className = 'status connected';
            };
            
            evtSource.onmessage = function(e) {
                try {
                    const event = JSON.parse(e.data);
                    addEvent(event);
                } catch (err) {
                    console.error('Failed to parse event:', err);
                }
            };
            
            evtSource.onerror = function() {
                connectionStatus.textContent = 'Disconnected';
                connectionStatus.className = 'status disconnected';
                evtSource.close();
                
                // Reconnect after 5 seconds
                setTimeout(connect, 5000);
            };
        }

        // Start connection
        connect();
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;`
        
        w.Header().Set("Content-Type", "text/html")
        _, _ = w.Write([]byte(html))
}</span>

func main() <span class="cov0" title="0">{
        mux := http.NewServeMux()

        // API endpoints
        mux.HandleFunc("/api/health", healthHandler)
        mux.HandleFunc("/api/users", usersHandler)
        mux.HandleFunc("/api/products", productsHandler)
        mux.HandleFunc("/metrics", metricsHandler)
        
        // Activity feed endpoints
        mux.HandleFunc("/api/events/stream", sseHandler)
        mux.HandleFunc("/activity-feed", activityFeedHandler)

        // Apply rate limiting middleware to all requests
        rateLimitedMux := RateLimitMiddleware(mux)

        log.Println("Starting server on :8080 with rate limiting (100 req/min per IP)")
        log.Fatal(http.ListenAndServe(":8080", rateLimitedMux))
}</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "fmt"
        "net"
        "net/http"
        "os"
        "strings"
        "sync"
        "time"
)

// RateLimiter tracks requests per IP
type RateLimiter struct {
        mu       sync.RWMutex
        requests map[string][]time.Time
        limit    int
        window   time.Duration
}

var (
        limiter            *RateLimiter
        distributedLimiter *DistributedRateLimiter
        useDistributed     bool
        globalEventEmitter *EventEmitter
)

func init() <span class="cov8" title="1">{
        initializeRateLimiter()
}</span>

// initializeRateLimiter initializes the rate limiting system
func initializeRateLimiter() <span class="cov8" title="1">{
        // Initialize global event emitter
        globalEventEmitter = &amp;EventEmitter{
                feed:        NewActivityFeed(1000),
                broadcaster: NewSSEBroadcaster(),
        }
        
        // Check if Redis URL is provided
        redisURL := os.Getenv("REDIS_URL")
        if redisURL != "" </span><span class="cov8" title="1">{
                // Try to initialize distributed rate limiter
                cfg := &amp;Config{
                        RedisURL:         redisURL,
                        Limit:            100,
                        Window:           time.Minute,
                        FailureThreshold: 5,
                        RecoveryInterval: 10 * time.Second,
                }
                
                drl, err := NewDistributedRateLimiter(cfg, globalEventEmitter)
                if err == nil </span><span class="cov8" title="1">{
                        distributedLimiter = drl
                        useDistributed = true
                        fmt.Println("Using distributed rate limiter with Redis")
                }</span> else<span class="cov8" title="1"> {
                        fmt.Printf("Failed to initialize distributed rate limiter: %v\n", err)
                        fmt.Println("Falling back to in-memory rate limiter")
                }</span>
        }
        
        // Always initialize the fallback limiter
        <span class="cov8" title="1">limiter = &amp;RateLimiter{
                requests: make(map[string][]time.Time),
                limit:    100,
                window:   time.Minute,
        }

        // Cleanup old entries periodically
        go func() </span><span class="cov8" title="1">{
                ticker := time.NewTicker(time.Minute)
                defer ticker.Stop()
                for range ticker.C </span><span class="cov0" title="0">{
                        limiter.cleanup()
                }</span>
        }()
}

// RateLimitMiddleware creates middleware that limits requests per IP
func RateLimitMiddleware(next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                ip := getClientIP(r)

                var allowed bool
                if useDistributed &amp;&amp; distributedLimiter != nil </span><span class="cov0" title="0">{
                        allowed = distributedLimiter.AllowWithRequest(ip, r)
                }</span> else<span class="cov8" title="1"> {
                        allowed = limiter.allow(ip)
                        // Emit event for local rate limiter too
                        if !allowed &amp;&amp; globalEventEmitter != nil </span><span class="cov8" title="1">{
                                globalEventEmitter.EmitRateLimitRejection(r)
                        }</span>
                }

                <span class="cov8" title="1">if !allowed </span><span class="cov8" title="1">{
                        w.Header().Set("Content-Type", "application/json")
                        w.WriteHeader(http.StatusTooManyRequests)
                        _, _ = w.Write([]byte(`{"error":"Rate limit exceeded. Maximum 100 requests per minute allowed."}`))
                        return
                }</span>

                <span class="cov8" title="1">next.ServeHTTP(w, r)</span>
        })
}

// allow checks if request from IP is allowed
func (rl *RateLimiter) allow(ip string) bool <span class="cov8" title="1">{
        rl.mu.Lock()
        defer rl.mu.Unlock()

        now := time.Now()
        windowStart := now.Add(-rl.window)

        // Get or create request list for IP
        requests, exists := rl.requests[ip]
        if !exists </span><span class="cov8" title="1">{
                rl.requests[ip] = []time.Time{now}
                return true
        }</span>

        // Remove old requests outside window
        <span class="cov8" title="1">validRequests := []time.Time{}
        for _, reqTime := range requests </span><span class="cov8" title="1">{
                if reqTime.After(windowStart) </span><span class="cov8" title="1">{
                        validRequests = append(validRequests, reqTime)
                }</span>
        }

        // Check if under limit
        <span class="cov8" title="1">if len(validRequests) &gt;= rl.limit </span><span class="cov8" title="1">{
                rl.requests[ip] = validRequests
                return false
        }</span>

        // Add current request
        <span class="cov8" title="1">validRequests = append(validRequests, now)
        rl.requests[ip] = validRequests
        return true</span>
}

// cleanup removes old entries
func (rl *RateLimiter) cleanup() <span class="cov8" title="1">{
        rl.mu.Lock()
        defer rl.mu.Unlock()

        now := time.Now()
        windowStart := now.Add(-rl.window)

        for ip, requests := range rl.requests </span><span class="cov8" title="1">{
                validRequests := []time.Time{}
                for _, reqTime := range requests </span><span class="cov8" title="1">{
                        if reqTime.After(windowStart) </span><span class="cov8" title="1">{
                                validRequests = append(validRequests, reqTime)
                        }</span>
                }

                <span class="cov8" title="1">if len(validRequests) == 0 </span><span class="cov8" title="1">{
                        delete(rl.requests, ip)
                }</span> else<span class="cov8" title="1"> {
                        rl.requests[ip] = validRequests
                }</span>
        }
}

// getClientIP extracts client IP from request
func getClientIP(r *http.Request) string <span class="cov8" title="1">{
        // Check X-Forwarded-For header
        xff := r.Header.Get("X-Forwarded-For")
        if xff != "" </span><span class="cov8" title="1">{
                ips := strings.Split(xff, ",")
                if len(ips) &gt; 0 </span><span class="cov8" title="1">{
                        return strings.TrimSpace(ips[0])
                }</span>
        }

        // Check X-Real-IP header
        <span class="cov8" title="1">xri := r.Header.Get("X-Real-IP")
        if xri != "" </span><span class="cov8" title="1">{
                return xri
        }</span>

        // Fall back to RemoteAddr
        <span class="cov8" title="1">ip, _, err := net.SplitHostPort(r.RemoteAddr)
        if err != nil </span><span class="cov8" title="1">{
                // If SplitHostPort fails, RemoteAddr might not have a port
                return r.RemoteAddr
        }</span>
        <span class="cov8" title="1">return ip</span>
}

// resetRateLimiter clears all rate limit data (for testing)
func resetRateLimiter() <span class="cov8" title="1">{
        limiter.mu.Lock()
        defer limiter.mu.Unlock()
        limiter.requests = make(map[string][]time.Time)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
